import matplotlib.pyplot as plt
import scipy.signal as spy
from pprint import pprint
from pathlib import Path
import scipy.fft as fft
import pandas as pd
import numpy as np
import pdb
import os

def smooth(data, kernel_size):
    '''apply a smoothing kernel of length kernel_size to 1D data
    '''
    kernel = np.ones(kernel_size) / kernel_size
    return np.convolve(data, kernel, mode='same')

def downsampling_funct(d_array, initial_fs, final_fs):
    """
    down sampling function
    downsampling from 32 khz to 1khz
    initial_fs = initial smapling rate
    final_fs = final sampling rate
    1_d_array = 1 d rray with samples(ep_single channel data)
    """
    downsampling_factor = np.floor(initial_fs/final_fs)
    dat_idx = np.arange(0,len(d_array), downsampling_factor).astype(np.int32)
    ds_dat = d_array[dat_idx]
    return ds_dat

def filter_data(data, cutoff, filt_type, fs, order=3):
    '''
    creates and applies a filter
    '''
    b, a = spy.butter(order, cutoff, btype = filt_type, analog=False, output='ba', fs=fs)
    return spy.filtfilt(b, a, data)
    """
    b, a = spy.butter(order, cutoff, analog=False, output='ba', fs=fs)
    return spy.filtfilt(b, a, data)
    """
def data_to_event(data,event_code,event_time,target,bt,at):
    """
    event parsing function.
    we take one event occurence
    data= all channel data as numpy array
    event code = translates to the specific triger that's generated by the software
    it can be a ttl in one comun that saves the state of a particular controller
    (eg: airpuff on), if there's an event start and event end then there will be
    two event codes.It will have all the events stored as a vector, we can call one
    event of our interest later on as target.
    event time = time stamp of all the  events are happening (if it's a longer duration
    event there will be a start and end time for the event)
    target = event of interest (exact time at the event happens)
    bt = before triger (left interval start point to consider)
    at = after triger (right interval end point to consider)
    """
    evnt_idx = np.nonzero(event_code==target)[0]
    start_idx = (event_time[evnt_idx]-bt).astype(np.int32)
    end_idx = (event_time[evnt_idx]+at).astype(np.int32)
#    pdb.set_trace()
    """
    The dimention of resulting array is all channels (32 in our case), time,
    number of trials, we are saving all channels all time (from start to begin
    from event time) and then all indices(for an event in particular)
    """
    trgt_evnt= np.zeros([data.shape[1],bt+at,len(evnt_idx)])
    for i in range(len(evnt_idx)):
        trgt_evnt[:,:,i] = np.transpose(data[start_idx[i]:end_idx[i],:])
    return trgt_evnt

def downsampling_funct(d_array, initial_fs, final_fs):
    """
    down sampling function
    downsampling from 32 khz to 1khz
    initial_fs = initial smapling rate
    final_fs = final sampling rate
    1_d_array = 1 d rray with samples(ep_single channel data)
    """
    downsampling_factor = np.floor(initial_fs/final_fs)
    dat_idx = np.arange(0,len(d_array), downsampling_factor).astype(np.int32)
    ds_dat = d_array[dat_idx]
    return ds_dat

def read_bin(file_path, type_d):
    """
    Open binary with any dtype you want
    """
    file_path = str(file_path)
    file_1 = open(file_path, "rb")
    file_1_arr = np.fromfile(file_1,type_d)
    print(file_1)
    return file_1_arr

def plot_all_chan(data, sampling_rate=30000, separation=10000):
    '''
    creates a figure with the first second over all channels in data,
    seperated by separation uvolts
    '''
    plt.figure()
    for i in range(data.shape[1]):
        c_data = data[:sampling_rate, i]
        c_data = c_data + i*separation
        plt.plot(c_data, label=str(i))
    plt.legend()
    return

def fourier_dat(data, gaussian_func):
    """
    the function takes the data window with 1D array and multiply it with a
    gaussian of preference. The signal/data array is tehn used for fourier and calculate the power of it and return the power.
    """
    data = data*gaussian_func
    a = fft.fft(data)
    a = np.square(np.abs(a))
    return a

def move_av(data,n):
    """
    moving average calculation using npy convolution function
    data = 1D data,
    n= moving window length
    """
    window = np.ones(n)/n
    resolved = np.convolve(data,window,mode='same')
    return resolved
